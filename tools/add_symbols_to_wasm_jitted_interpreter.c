/**
 * This tool is used for debugging the code generated by a just-in-time
 * compiler for the WebAssembly version of the interpreter.
 *
 * It adds symbols to the large interpret branch table so that the
 * implementation of an instruction is easy to find.
 */
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <libelf.h>

char *add_text_section(Elf *e, char *disas_filename, unsigned long *prog_size) {
	FILE *disas;
	Elf64_Shdr *shdr;
	Elf_Scn *scn;
	Elf_Data *data;

	if ((disas=fopen(disas_filename, "rb")) == NULL)
		errx(EXIT_FAILURE, "fopen %s failed",disas_filename);
	fseek(disas,0,SEEK_END);
	*prog_size=ftell(disas);
	fseek(disas,0,SEEK_SET);
	char *prog_mem=malloc(*prog_size);
	fread(prog_mem,*prog_size,1,disas);
	fclose(disas);

	if ((scn=elf_newscn(e)) == NULL)
		errx(EXIT_FAILURE, "elf_newscn() failed: %s",elf_errmsg(-1));
	if ((data=elf_newdata(scn)) == NULL)
		errx(EXIT_FAILURE, "elf_newdata() failed: %s",elf_errmsg(-1));
	data->d_align=4;
	data->d_off=0LL;
	data->d_buf=prog_mem;
	data->d_type=ELF_T_WORD;
	data->d_size=*prog_size;
	data->d_version=EV_CURRENT;

	if ((shdr=elf64_getshdr(scn)) == NULL)
		errx(EXIT_FAILURE, "elf64_getshdr() failed: %s",elf_errmsg(-1));
	shdr->sh_name=1;
	shdr->sh_type=SHT_PROGBITS;
	shdr->sh_flags=SHF_EXECINSTR|SHF_ALLOC;
	shdr->sh_entsize=0;

	return prog_mem;
}

#define ABC_INSTRUCTIONS_H "../src/abc_instructions.h"

char string_table[12000] = {
	/*  0 */ '\0',
	/*  1 */ 'm','a','i','n','\0',
	/*  6 */ 'l','o','o','p','\0',
	/* 11 */
};
unsigned int string_table_i=11;

int load_instruction_names(void) {
	FILE *f;

	if ((f=fopen(ABC_INSTRUCTIONS_H, "r")) == NULL)
		errx(EXIT_FAILURE, "fopen %s failed",ABC_INSTRUCTIONS_H);

	char* line = NULL;
	size_t size = 0;
	int n_instr = 0;

	while (getline(&line, &size, f) > 0) {
		if (strncmp(line,"\tINSTRUCTION(",13)!=0)
			continue;

		char *end=strchr(line,')');
		if (end==NULL)
			errx(EXIT_FAILURE,"warning: no delimiting ) found in line '%s'\n",line);

		int len = end-line-13;
		strncpy(string_table+string_table_i,line+13,len);
		string_table[string_table_i+len]='\0';
		string_table_i+=len+1;

		n_instr++;
	}

	free(line);
	fclose(f);

	return n_instr;
}

int add_strtab_section(Elf *e) {
	Elf64_Shdr *shdr;
	Elf_Scn *scn;
	Elf_Data *data;

	int n_instr=load_instruction_names();

	if ((scn=elf_newscn(e)) == NULL)
		errx(EXIT_FAILURE, "elf_newscn() failed: %s",elf_errmsg(-1));
	if ((data=elf_newdata(scn)) == NULL)
		errx(EXIT_FAILURE, "elf_newdata() failed: %s",elf_errmsg(-1));
	data->d_align=1;
	data->d_buf=string_table;
	data->d_off=0LL;
	data->d_size=string_table_i;
	data->d_type=ELF_T_BYTE;
	data->d_version=EV_CURRENT;

	if ((shdr=elf64_getshdr(scn)) == NULL)
		errx(EXIT_FAILURE, "elf64_getshdr() failed: %s",elf_errmsg(-1));
	shdr->sh_name=7;
	shdr->sh_type=SHT_STRTAB;
	shdr->sh_flags=SHF_STRINGS|SHF_ALLOC;
	shdr->sh_entsize=0;

	return n_instr;
}

uint64_t *find_start_of_br_table(uint64_t *code, unsigned int size) {
	unsigned int optimum=0;
	unsigned int opt_size=1;

	uint8_t *code8=(uint8_t*)code;
	size<<=3;

	for (unsigned int i=0; i<size; i++) {
		code=(uint64_t*)&code8[i];
		uint64_t this_high=code[0]>>24;
		unsigned int j=0;
		for (; j<(size-i)>>3; j++)
			if ((code[j]>>24)!=this_high)
				break;
		if (j > opt_size) {
			opt_size=j;
			optimum=i;
			fprintf(stderr,"new optimum %d at %d: 0x%010lx......\n",opt_size,optimum,this_high);
		}
	}

	return (uint64_t*)&code8[optimum];
}

char *find_movabs_of_br_table(char *code, unsigned int size, uint64_t high_bytes) {
	for (unsigned int i=0; i<size; i++) {
		if ((code[i+1]&0xf8)==0xb8
				&& code[i+5]==(char)((high_bytes>> 0)&0xff)
				&& code[i+6]==(char)((high_bytes>> 8)&0xff)
				&& code[i+7]==(char)((high_bytes>>16)&0xff)
				&& code[i+8]==(char)((high_bytes>>24)&0xff)
				&& code[i+9]==(char)((high_bytes>>32)&0xff)) {
			if (code[i]==0x48)
				return &code[i];
			if (code[i]==0x49)
				return &code[i+1];
		}
	}

	errx(EXIT_FAILURE,"find_movabs_of_br_table() could not find movabs");
}

void add_symbols_section(Elf *e, char *prog_mem, unsigned long prog_size, int n_instrs) {
	Elf64_Shdr *shdr;
	Elf_Scn *scn;
	Elf_Data *data;

	uint64_t *br_table_start=find_start_of_br_table((uint64_t*)prog_mem, prog_size/8);
	fprintf(stderr,"br_table_start at %p from %p; %ld bytes\n",(void*)br_table_start,prog_mem,(uint64_t)br_table_start-(uint64_t)prog_mem);
	char *movabs=find_movabs_of_br_table(prog_mem,prog_size,br_table_start[0]>>24);
	uint64_t absolute_br_table_start=*(uint64_t*)(movabs+2);
	fprintf(stderr,"movabs at %p from %p; %ld bytes with constant %p\n",
			movabs,prog_mem,(uint64_t)movabs-(uint64_t)prog_mem,(void*)absolute_br_table_start);
	uint64_t absolute_start=absolute_br_table_start-((uint64_t)br_table_start-(uint64_t)prog_mem);
	fprintf(stderr,"absolute start address is %lx\n",absolute_start);

	Elf64_Sym *symbols=malloc((n_instrs+3)*sizeof(Elf64_Sym));
	unsigned int s_i=11;
	for (int i=1; i<=n_instrs; i++) {
		symbols[i].st_name=s_i;
		symbols[i].st_info=ELF64_ST_INFO(STB_GLOBAL,STT_FUNC);
		symbols[i].st_other=STV_DEFAULT;
		symbols[i].st_shndx=1; /* .text */
		symbols[i].st_value=br_table_start[i-1]-absolute_start;
		symbols[i].st_size=0;
		while (string_table[s_i++]);
	}

	/* main function */
	symbols[n_instrs+1].st_name=1;
	symbols[n_instrs+1].st_info=ELF64_ST_INFO(STB_GLOBAL,STT_FUNC);
	symbols[n_instrs+1].st_other=STV_DEFAULT;
	symbols[n_instrs+1].st_shndx=1; /* .text */
	symbols[n_instrs+1].st_value=0;
	symbols[n_instrs+1].st_size=0;

	/* loop */
	symbols[n_instrs+2].st_name=6;
	symbols[n_instrs+2].st_info=ELF64_ST_INFO(STB_GLOBAL,STT_FUNC);
	symbols[n_instrs+2].st_other=STV_DEFAULT;
	symbols[n_instrs+2].st_shndx=1; /* .text */
	symbols[n_instrs+2].st_value=movabs-prog_mem+10;
	symbols[n_instrs+2].st_size=0;

	if ((scn=elf_newscn(e)) == NULL)
		errx(EXIT_FAILURE, "elf_newscn() failed: %s",elf_errmsg(-1));
	if ((data=elf_newdata(scn)) == NULL)
		errx(EXIT_FAILURE, "elf_newdata() failed: %s",elf_errmsg(-1));
	data->d_align=1;
	data->d_buf=symbols;
	data->d_off=0LL;
	data->d_size=(n_instrs+3)*sizeof(Elf64_Sym);
	data->d_type=ELF_T_SYM;
	data->d_version=EV_CURRENT;

	if ((shdr=elf64_getshdr(scn)) == NULL)
		errx(EXIT_FAILURE, "elf64_getshdr() failed: %s",elf_errmsg(-1));
	shdr->sh_link=2; /* link to .strtab */
	shdr->sh_name=25;
	shdr->sh_type=SHT_SYMTAB;
	shdr->sh_flags=0;
	shdr->sh_entsize=DT_SYMENT;
}

char shstrtab[] = {
	/*  0 */ '\0',
	/*  1 */ '.','t','e','x','t',
	         '\0',
	/*  7 */ '.','s','t','r','t',
	         'a','b','\0',
	/* 15 */ '.','s','h','s','t',
	         'r','t','a','b','\0',
	/* 25 */ '.','s','y','m','t',
	         'a','b','\0',
	/* 33 */
};

void add_shstrtab_section(Elf *e) {
	Elf64_Shdr *shdr;
	Elf_Scn *scn;
	Elf_Data *data;

	if ((scn=elf_newscn(e)) == NULL)
		errx(EXIT_FAILURE, "elf_newscn() failed: %s",elf_errmsg(-1));
	if ((data=elf_newdata(scn)) == NULL)
		errx(EXIT_FAILURE, "elf_newdata() failed: %s",elf_errmsg(-1));
	data->d_align=1;
	data->d_buf=shstrtab;
	data->d_off=0LL;
	data->d_size=sizeof(shstrtab);
	data->d_type=ELF_T_BYTE;
	data->d_version=EV_CURRENT;

	if ((shdr=elf64_getshdr(scn)) == NULL)
		errx(EXIT_FAILURE, "elf64_getshdr() failed: %s",elf_errmsg(-1));
	shdr->sh_name=15;
	shdr->sh_type=SHT_STRTAB;
	shdr->sh_flags=SHF_STRINGS|SHF_ALLOC;
	shdr->sh_entsize=0;
}

int main(int argc, char **argv) {
	int fd;
	Elf *e;
	Elf64_Ehdr *ehdr;
	Elf64_Phdr *phdr;

	if (argc!=3)
		errx(EXIT_FAILURE, "usage: %s disas-interpret.bin interpret.o",argv[0]);

	if (elf_version(EV_CURRENT)==EV_NONE)
		errx(EXIT_FAILURE, "ELF library initialization failed: %s",elf_errmsg(-1));

	if ((fd=open(argv[2], O_WRONLY|O_CREAT, 0777)) < 0)
		errx(EXIT_FAILURE, "open %s failed",argv[2]);

	if ((e=elf_begin(fd, ELF_C_WRITE, NULL)) == NULL)
		errx(EXIT_FAILURE, "elf_begin() failed: %s",elf_errmsg(-1));

	if ((ehdr=elf64_newehdr(e)) == NULL)
		errx(EXIT_FAILURE, "elf64_newehdr() failed: %s",elf_errmsg(-1));
	ehdr->e_ident[EI_DATA]=ELFDATA2LSB;
	ehdr->e_machine=EM_X86_64;
	ehdr->e_type=ET_REL;

	if ((phdr=elf64_newphdr(e,1)) == NULL)
		errx(EXIT_FAILURE, "elf64_newphdr() failed: %s",elf_errmsg(-1));

	unsigned long prog_size;
	char *prog_mem=add_text_section(e,argv[1],&prog_size);
	int n_instrs=add_strtab_section(e);
	add_symbols_section(e,prog_mem,prog_size,n_instrs);
	add_shstrtab_section(e);

	if (elf_update(e,ELF_C_NULL)<0)
		errx(EXIT_FAILURE, "elf_update(NULL) failed: %s",elf_errmsg(-1));

	phdr->p_type=PT_PHDR;
	phdr->p_offset=ehdr->e_phoff;
	phdr->p_filesz=elf64_fsize(ELF_T_PHDR,1,EV_CURRENT);

	ehdr->e_shstrndx=4; /* number of sections, since the .shstrtab is the last one */

	(void) elf_flagphdr(e, ELF_C_SET, ELF_F_DIRTY);
	if (elf_update(e, ELF_C_WRITE)<0)
		errx(EXIT_FAILURE, "elf_update() failed: %s",elf_errmsg(-1));

	(void) elf_end(e);
	(void) close(fd);

	exit(EXIT_SUCCESS);
}
